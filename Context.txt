作用：Context主要用来在goroutine之间传递上下文信息，目的是实现并发控制和超时控制。
在Go写的后台服务器中，收到请求通都会创建goroutine进行处理，而goroutine本身又可以创建goroutine。这样对于一个请求就有多个goroutine同时工作。
当请求处理时间太长或者请求被取消的时候，需要关闭所有正在处理该请求的goroutine流程。但是对于任一goroutine，尤其是前面创建的goroutine并不知道后面创建了哪些goroutine。
Context就提供了goroutine之间通知退出、共享数据传递的功能。

type Context interface {
    Deadline() (deadline time.TIme, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
Context的方法说明了Context提供的功能。
Deadline是设置一个超时时间，到了时间自动取消。
Done返回一个被关闭的channel，相当于一个取消通知。
Err在channel关闭后返回关闭的原因。
Value提供了值存储的功能。

Context.Background()
func Background() Context {
    return background
}
返回一个非nil的空Context，往往作为最上层的Context在main函数或初始化函数或者收到一个新的请求的时候调用。
Context本身是一个接口而非结构，background实际上是一个实现了Context定义的方法的全局变量。这个空Context不会被Cancel，没有deadline，也没有存储值。
background返回的Context所定义的Done()函数只会返回一个nil。单独执行background的Done()没有意义。

================================================
type cancelCtx struct {
	Context

	mu       sync.Mutex            // protects following fields
	done     chan struct{}         // created lazily, closed by first cancel call
	children map[canceler]struct{} // set to nil by the first cancel call
	err      error                 // set to non-nil by the first cancel call
}
一个可以取消的Context，将Context作为一个匿名字段。通过withCancel(parent Context)创建，返回一个context和用来取消context的函数。传入的parent Context一般是上面说的Context.Background()。
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
	c := newCancelCtx(parent)
	propagateCancel(parent, &c)
	return &c, func() { c.cancel(true, Canceled) }  //这里的true表示在关闭的时候会将自己从parent中删除。
}

func newCancelCtx(parent Context) cancelCtx {
	return cancelCtx{Context: parent} //将cancelCtx的匿名字段赋值为parent
}

func propagateCancel(parent Context, child canceler) {
	if parent.Done() == nil {   //如果parent是Context.Background()，就符合这个条件，因为Background创建的context不能取消。
		return // parent is never canceled
	}
	if p, ok := parentCancelCtx(parent); ok { //针对不同的parent类型的处理，找到可以取消的parent。
		p.mu.Lock()
		if p.err != nil {
			// parent has already been canceled
			child.cancel(false, p.err)
		} else {
			if p.children == nil {
				p.children = make(map[canceler]struct{})    //将新创建的context添加为parent的children，在parent关闭的时候会用到
			}
			p.children[child] = struct{}{}
		}
		p.mu.Unlock()
	} else {
        //为什么会有这个分支是因为下面parentCancelCtx只匹配了三种基本类型的Context，但实际在使用的时候，用户可以自定义一个Context类型作为parent
        //这种情况就进入到了该分支
		go func() {     //如果没有可取消的parent，则新建一个协程用来监听parent和child的取消信号
			select {
			case <-parent.Done():
				child.cancel(false, parent.Err())
			case <-child.Done():
			}
		}()
	}
}

func parentCancelCtx(parent Context) (*cancelCtx, bool) {
	for {
		switch c := parent.(type) {
		case *cancelCtx:
			return c, true
		case *timerCtx:
			return &c.cancelCtx, true
		case *valueCtx:
			parent = c.Context
		default:
			return nil, false
		}
	}
}

func (c *cancelCtx) Done() <-chan struct{} {
	c.mu.Lock()
	if c.done == nil {
		c.done = make(chan struct{})    //新创建的cancelCtx的done是nil，没赋值。在第一次Done的时候创建一个chan
	}
	d := c.done
	c.mu.Unlock()
	return d
}
返回了一个只读的chan，但是chan里没有数据。

cancel函数就是withCancel返回给外层的
func (c *cancelCtx) cancel(removeFromParent bool, err error) {
	if err == nil {
		panic("context: internal error: missing cancel error")
	}
	c.mu.Lock()
	if c.err != nil {
		c.mu.Unlock()
		return // already canceled
	}
	c.err = err
	if c.done == nil {
		c.done = closedchan //closedchan是一个全局变量
	} else {
		close(c.done)
	}

    //关键就是这个过程，循环调用context所有的子context，然后逐一关闭
	for child := range c.children {
		// NOTE: acquiring the child's lock while holding parent's lock.
		child.cancel(false, err)
	}
	c.children = nil
	c.mu.Unlock()

	if removeFromParent {           //在创建withCancel中固定传入是true
		removeChild(c.Context, c)   //从parent中将自己删除
	}
}
================================================
type timerCtx struct {
	cancelCtx
	timer *time.Timer // Under cancelCtx.mu.

	deadline time.Time
}
在cancelCtx的基础之上多了一个定时器和超时时间。

func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
	return WithDeadline(parent, time.Now().Add(timeout))
}

func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {
	//判断parent是否会在给定的超时时间之前超时，如果parent节点超时在前，那么直接返回一个可取消的parent
    //如果parent超时，那么child也都会取消，不需要单独处理child的超时
    if cur, ok := parent.Deadline(); ok && cur.Before(d) {
		// The current deadline is already sooner than the new one.
		return WithCancel(parent)
	}
	c := &timerCtx{
		cancelCtx: newCancelCtx(parent),
		deadline:  d,
	}
	propagateCancel(parent, c)
	dur := time.Until(d)
	if dur <= 0 {
		c.cancel(true, DeadlineExceeded) // deadline has already passed
		return c, func() { c.cancel(false, Canceled) }
	}
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.err == nil {
		c.timer = time.AfterFunc(dur, func() {
			c.cancel(true, DeadlineExceeded)    //超时之后自动调用cancel，传入的err就是DeadlineExceeded
		})
	}
	return c, func() { c.cancel(true, Canceled) }   //同时也返回了一个cancel函数可以由使用者调用
}
================================================
type valueCtx struct {
    Context
    key, val interface{}
}

func WithValue(parent Context, key, val interface{}) Context {
	if key == nil {
		panic("nil key")
	}
	if !reflectlite.TypeOf(key).Comparable() {
		panic("key is not comparable")
	}
	return &valueCtx{parent, key, val}  //通过任意的valueCtx都可以找到对应的parent，但是通过parent却没法找到valueCtx。
}

func (c *valueCtx) Value(key interface{}) interface{} {
	if c.key == key {
		return c.val
	}
	return c.Context.Value(key)     //递归查找，如果当前的context没有对应的key，就找parent。
}