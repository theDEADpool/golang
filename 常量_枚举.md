# GO语言 #
## 常量 ##

常量的定义的语法格式和变量类似，关键字`const`。

    const a int = 1
	const a, b, c = 1, 2, "3"
	const (
		a = 1
		b = 2
		c = 3
	)
	const (
		a, b, c = 1, 2, 3	
	)

GO语言在常量组中，如果某一个常量不赋值，会默认赋值为前一个常量的值。

    const (
		a = 1
		b
		c
	)

这种实际上a, b, c都 = 1。

但是对于下面这些写法，是不满足上面的规则。

    const a int = 1
	const b int
	const c int

编译器会报错`syntax error: unexpected semicolon or newline, expecting =`。

	const (
		a, b = 1, 2
		c
	)

这种编译器也会报错，如果想要使用常量初始化规则，那么每一行的常量个数必须是一致的。

无类型常量
Go语言支持常量没有明确的基础类型。比如const pi = 3.141592653
无类型常量的优点就是可以有非常高的精度。常规的类型比如byte精度就是-128~128。无类型常量的精度则非常的大，至少有256位的精度。
无类型常量也可以赋值给有明确类型的变量，前提是变量的类型精度必须能够表示无类型变量的值，否则会出错。

有一点需要注意，无类型的常量转换成int类型的变量，变量的内存大小是不确定的。因为int类型本身的大小是依赖于编译器的，不同的编译器即使在相同的硬件上得到的int类型大小也可能是不同的。

## 枚举 ##

关键字`iota`，初始化为0，组中每定义一个常量，则自增1。当遇到`const`关键字，则重置为0。

	const (
		a = iota
		b
		c
	)

	a = 0, b = 1, c = 2

	const (
		a = 10
		b = iota
		c = 11
		d = iota
	)

	a = 10, b = 1, c = 11, d = 3

注意第二个例子，`c = 2`，这是因为组中已经定义了`a`, `b`两个常量，所以`iota`自增为2。这就是最开始说的，每定义一个常量，则`iota`自增1，和第几次使用`iota`没关系。

同时第二个例子还需要注意的是，当`iota`的使用出现了中断，后面如果想继续使用iota的值，需要显式的恢复，就像`d = iota`一样。

	const (
		a = iota
		b
	)

	const (
		e = iota
	)

	a = 0, b = 1, e = 0

这就是`iota`遇到const被重置为0。

	const (
		a, b = iota, iota
		c, d
	)

	a = 0, b = 0, c = 1, d = 1

在一个常量组内，可以有多个`iota`分开计数。如果分开计数，则要求常量组每一行的常量个数都是相同的。