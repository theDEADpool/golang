# GO语言 #
## 数组 ##

**定义**

	var <varName> [n]<type>

如果已知数组中每个成员具体的值，可以采用这种写法。

    a := [2]int{1, 2}

甚至可以在定义的时候给具体某一个下标的成员赋值，而其他不赋值。

	a := [10]int{9:1}

这样就可以给下标为9的成员赋值为1，其他不赋值。

上面两种情况，都可以不需要指定数组具体的长度，由编译器自动计算。

    a := [...]int{1, 2}
	a := [...]int{9:1}

数组指针`var p *[2]int`。

指针数组`var p [2]*int`。

数组的数组`var a [2][3]int`，这个定义的意思就是`a`是一个长度为2的数组，而`a`的每个成员是长度为3的int型数组。

**特性**

只有相同类型相同长度的数组可以直接用`=`赋值。其他情况都不能用`=`来进行赋值。

GO语言中相同长度相同类型的数组之间可以使用`==`或者`!=`进行逻辑比较，但不能使用`>`或者`<`进行比较。其他情况的数组之间都不能进行逻辑比较。

GO语言中如果将一个数组作为参数传入方法或者函数，那么传入的是该数组的一个拷贝。这不同于C语言中，将数组传入一个参数传入的是数组的指针。

可以使用`new`关键字来创建一个数组。

    p := new([2]int)

这里`p`是一个指向数组的指针。

## 分片 ##

**定义**

    var <varName> []<varType>

`[]`没有指定具体个数也没有`...`，这种定义就是`slice`。

`slice`是一种指向数组中部分或者全部成员的数据结构。

    a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	s1 := a[:5]
	s2 := a[1:4]
	s3 := a[5:]

`s1`表示取数组`a`中从开始到下标为4，注意不包括下标为5的成员。

`s2`表示取数组`a`中下标为1到3的3个成员。

`s3`表示取数组`a`中从下标5开始到数组最后的所有成员。

通过`make`方法来定义一个`slice`。

	varName := make([]<type>, len, cap)

这种方式指定了一个`slice`的完整属性。其中`len`表示该`slice`有多少个成员需要初始化，`cap`则表示了该`slice`的最大容量。

	s1 := make([]int, 2, 10)
	fmt.Println(s1)

	[0 0]

`len`指定为2，则表示`slice`中有2个成员需要被初始化。

当`len <= cap`时，`slice`都不需要重新分配内存。但当`len > cap`时，则会重新分配新的内存给该`slice`。新内存的`cap`是在旧`cap`的基础上 * 2。比如之前是10，当实际存储的成员个数为11时，新分配的内存`cap = 10 * 2 = 20`。

更高级一点的用法，我们也可以针对一个`slice`再创建一个`slice`。

	a := [5]int{1, 2, 3, 4, 5}
	s1 := a[1:]

这里`s1`的成员为2，3，4，5。

如果需要通过`s1`得到3，4。那么`s2 := s1[1:3]`。值得注意的是，`s2`使用的下标是以`s1`为基准，而不是以数组`a`为基准的。

**特性**

	a := [5]int{1, 2, 3, 4, 5}
	s1 := a[1:3]

根据上面的说明，可以知道`s1`中有2个成员2，3。可以通过下标的方式来访问，`s1[0] = 2, s1[1] = 3`。

但如果访问了`s1[2]`会出现什么结果呢？

会发现并不会出现访问错误，而是会得到`s1[2] = 4`。

之所以会得到这个结果是因为通过`s1 := a[1:3]`这种方式得到的`slice`，虽然指定是指向数组`a`中下标为1和2的两个成员。但实际上`s1`的`len`和`cap`都是4，等于从下标为1开始到数组最后一个成员的长度。因此才能成功访问`s1[2]`。

	s2 := s1[0:1]

这种情况下`s2`的`len`为1，而`cap`为4。`cap`的值和s1相同，但`len`却没有，这个要注意。

通过下标访问`slice`中的成员时，下标不能超过`slice`的`cap`容量。否则会出错。

如果改变数组中`slice`所指向的元素，那么通过下标访问`slice`，对应的值也会发生变化。反过来也是一样。

	a := [5]int{1, 2, 3, 4, 5}
	s1 := a[1:]

	fmt.Println(s1)
	//s1 = [2, 3, 4, 5]

	a[4] = 6

	fmt.Println(a, s1)
	//a = [1, 2, 3, 4, 6]
	//s1 = [2, 3, 4, 6]

	s1[3] = 7

	fmt.Println(a, s1)
	//a = [1, 2, 3, 4, 7]
	//s1 = [2, 3, 4, 7]

通过这个例子可以看出，`slice`用法和指针的用法类似。


**常用方法**

**append方法**

将新的成员或者其他`slice`追加到已有`slice`的尾部。
`append`之后的最终长度没有超过原`slice`的容量，则返回原`slice`。如果超过了原`slice`的容量，则系统会创建重新分配内存，并将原`slice`的数据进行拷贝，返回新的`slice`。

	s1 := make([]int, 3, 6)
	s1 = append(s1, 1, 2, 3)

上面说到`slice`和数组的成员其实指向相同的地址，不论哪一个发生变化都会互相影响。来看下面这个例子。

	a := [5]int{1, 2, 3, 4, 5}
	s1 := a[0:3]

	fmt.Println(s1)
	//s1 = [1, 2, 3]

	s1 = append(s1, 11, 12, 13)

	fmt.Println(s1)
	//s1 = [1, 2, 3, 11, 12, 13]

	s1[0] = 100

	fmt.Println(a, s1)
	//a = [1, 2, 3, 4, 5]
	//s1 = [100, 2, 3, 11, 12, 13]

会发现，改变了`s1[0]`之后，`a[0]`并没有发生相应的变化。

这就是因为，当通过`append`加入`s1`的成员超出了`s1`的容量之后。系统重新分配内存生产了一个新的`s1`。这个新的`s1`就不再是指向数组`a`的`slice`。因此改变`s1`是不会让数组`a`发生变化的。

**copy方法**

该方法用于两个`slice`之间的相互拷贝。

	s1 := []int{1, 2, 3, 4, 5}
	s2 := []int{11, 12}

	copy(s1, s2)

	fmt.Println(s1, s2)
	//s1 = [11, 12, 3, 4, 5]
	//s2 = [11, 12]

	s1 := []int{1, 2, 3, 4, 5}
	s2 := []int{11, 12}

	copy(s1, s2)

	fmt.Println(s1, s2)
	//s1 = [1, 2, 3, 4, 5]
	//s2 = [1, 2]

通过这个例子，可以看出`s1`的容量大于`s2`，当将`s2`拷贝到`s1`时，会完整拷贝`s2`中所有的内容。而将`s1`拷贝到`s2`时，只会拷贝`s2`容量所能接收的内容。

`copy`方法还可以指定拷贝`s2`中的某几个成员到`s1`中指定的某个位置。

	copy(s1[3:4], s2[1:2])
	fmt.Println(s1)

	//s1 = [1, 2, 3, 12, 5]

**迭代操作**

	for i,v := range slice{
		...
	}

其中`i`是`slice`的索引，`v`是`i`在`slice`中对应值的拷贝。对`v`的修改不会影响到`slice[i]`的值。